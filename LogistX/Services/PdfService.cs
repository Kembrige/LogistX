using DinkToPdf;
using DinkToPdf.Contracts;
using iTextSharp.text.pdf;
using iTextSharp.text;
using LogistX.Models;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Text;
using System.Threading.Tasks;

namespace LogistX.Services
{
    public class PdfService
    {
        private readonly IConverter _converter;

        public PdfService(IConverter converter)
        {
            _converter = converter;
        }

        /// <summary>
        /// Генерация PDF-файла из HTML-контента.
        /// </summary>
        /// <param name="htmlContent">HTML-содержимое для генерации PDF.</param>
        /// <returns>Байтовый массив PDF.</returns>
        public byte[] GeneratePdf(string htmlContent)
        {
            var doc = new HtmlToPdfDocument
            {
                GlobalSettings = new GlobalSettings
                {
                    ColorMode = ColorMode.Color,
                    Orientation = Orientation.Portrait,
                    PaperSize = PaperKind.A4,
                    Margins = new MarginSettings { Top = 10, Bottom = 10, Left = 10, Right = 10 },
                    DocumentTitle = "Generated PDF"
                }
            };

            // Добавляем объект отдельно
            var objectSettings = new ObjectSettings
            {
                PagesCount = true,
                HtmlContent = htmlContent,
                WebSettings = { DefaultEncoding = "utf-8", EnableJavascript = true },
                HeaderSettings = { FontSize = 9, Right = "Page [page] of [toPage]", Line = true },
                FooterSettings = { FontSize = 9, Center = "Generated by LogistX", Line = true }
            };

            doc.Objects.Add(objectSettings);

            return _converter.Convert(doc);
        }

        /// <summary>
        /// Сохранение PDF-файла в заданную директорию.
        /// </summary>
        /// <param name="pdfData">Байтовый массив PDF.</param>
        /// <param name="outputPath">Путь для сохранения PDF-файла.</param>
        public void SavePdf(byte[] pdfData, string outputPath)
        {
            if (string.IsNullOrEmpty(outputPath))
            {
                throw new ArgumentException("Output path cannot be null or empty.", nameof(outputPath));
            }

            var directory = Path.GetDirectoryName(outputPath);
            if (!Directory.Exists(directory))
            {
                Directory.CreateDirectory(directory);
            }

            File.WriteAllBytes(outputPath, pdfData);
        }


        public static MemoryStream toPDF(Invoice invoice)
        {
            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);


            var doc = new iTextSharp.text.Document();
            var stream = new MemoryStream();
            var pdfWriter = PdfWriter.GetInstance(doc, stream);
            pdfWriter.CloseStream = false;

            try
            {

                doc.Open();

                string arialFontPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Fonts), "arial.ttf");
                var baseFont = BaseFont.CreateFont(arialFontPath, BaseFont.IDENTITY_H, BaseFont.EMBEDDED);
                var font = new iTextSharp.text.Font(baseFont, 12, iTextSharp.text.Font.NORMAL, BaseColor.BLACK);


                doc.Add(new Paragraph("Company:", font));
                doc.Add(new Paragraph(invoice.Company.Name, font));

                doc.Add(new Paragraph("Route:", font));
                doc.Add(new Paragraph($"{invoice.Route.StartLocation} - {invoice.Route.EndLocation}", font));

                doc.Add(new Paragraph("Amount:", font));
                doc.Add(new Paragraph($"{invoice.Amount}", font));

                doc.Add(new Paragraph("Date:", font));
                doc.Add(new Paragraph(invoice.Date.ToShortDateString(), font));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка при создании PDF: {ex.Message}");
            }
            finally
            {
                doc.Close();
            }

            var byteInfo = stream.ToArray();
            stream.Write(byteInfo, 0, byteInfo.Length);
            stream.Position = 0;

            return stream;
        }
    }
}